<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <title>Note Link [v4.4 Core Engine Test]</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #paint-canvas {
      display: block;
      background-color: #f0f0f0;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="paint-canvas"></canvas>
<script type="module">
  const app = {
    VERSION: 'v4.4',
    dom: {},
    state: {
      isDrawing: false,
      dpr: 1,
      history: [],
      redoStack: [],
      pen: {
        color: '#1a1a1a',
        size: 5,
        lineCap: 'round'
      },
    },
    
    init() {
      this.cacheDom();
      this.addEventListeners();
      this.setupCanvas();
      console.log(`Note Link ${this.VERSION} Initialized`);
    },
    
    cacheDom() {
      this.dom = {
        canvas: document.getElementById('paint-canvas'),
        ctx: document.getElementById('paint-canvas').getContext('2d'),
      };
    },
    
    addEventListeners() {
      window.addEventListener('resize', () => this.setupCanvas());
      const canvas = this.dom.canvas;
      canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));
      canvas.addEventListener('pointermove', this.onPointerMove.bind(this));
      canvas.addEventListener('pointerup', this.onPointerUp.bind(this));
      canvas.addEventListener('pointerleave', this.onPointerUp.bind(this));

      // Undo/Redo with keyboard
      window.addEventListener('keydown', e => {
        if (e.ctrlKey || e.metaKey) {
          if (e.key === 'z') {
            e.preventDefault();
            this.undo();
          }
          if (e.key === 'y') {
            e.preventDefault();
            this.redo();
          }
        }
      });
    },
    
    setupCanvas() {
      this.saveHistory(false); // Save before resize
      
      this.state.dpr = window.devicePixelRatio || 1;
      const rect = this.dom.canvas.getBoundingClientRect();
      
      this.dom.canvas.width = rect.width * this.state.dpr;
      this.dom.canvas.height = rect.height * this.state.dpr;
      
      this.dom.ctx.scale(this.state.dpr, this.state.dpr);
      
      this.redrawHistory();
    },
    
    getCanvasCoordinates(e) {
      const rect = this.dom.canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    },
    
    onPointerDown(e) {
      if (e.pointerType === 'mouse' && e.button !== 0) return;
      this.saveHistory();
      this.state.isDrawing = true;

      const p = this.getCanvasCoordinates(e);
      this.prepareContext();

      this.dom.ctx.beginPath();
      this.dom.ctx.moveTo(p.x, p.y);
      // Draw a dot for single taps
      this.dom.ctx.fillStyle = this.state.pen.color;
      this.dom.ctx.arc(p.x, p.y, this.state.pen.size / 2, 0, 2 * Math.PI);
      this.dom.ctx.fill();
      this.dom.ctx.beginPath();
      this.dom.ctx.moveTo(p.x, p.y);
    },
    
    onPointerMove(e) {
      if (!this.state.isDrawing) return;
      const p = this.getCanvasCoordinates(e);
      this.dom.ctx.lineTo(p.x, p.y);
      this.dom.ctx.stroke();
    },
    
    onPointerUp() {
      if (!this.state.isDrawing) return;
      this.state.isDrawing = false;
      this.dom.ctx.closePath();
    },
    
    prepareContext() {
      const ctx = this.dom.ctx;
      const settings = this.state.pen;
      ctx.strokeStyle = settings.color;
      ctx.lineWidth = settings.size;
      ctx.lineCap = settings.lineCap;
      ctx.lineJoin = 'round';
    },

    saveHistory(clearRedo = true) {
      const { width, height } = this.dom.canvas;
      if (width > 0 && height > 0 && this.dom.ctx) {
          try {
              this.state.history.push(this.dom.ctx.getImageData(0, 0, width, height));
              if (this.state.history.length > 50) this.state.history.shift();
              if (clearRedo) this.state.redoStack = [];
          } catch (e) {
              console.error("History save failed:", e);
          }
      }
    },

    redrawHistory() {
      const lastState = this.state.history.at(-1);
      const ctx = this.dom.ctx;
      const { width, height } = this.dom.canvas;
      ctx.clearRect(0, 0, width, height);
      if (lastState) {
        try {
          ctx.putImageData(lastState, 0, 0);
        } catch (e) {
          console.error("History redraw failed:", e);
        }
      }
    },

    undo() {
      if (this.state.history.length === 0) return;
      const { width, height } = this.dom.canvas;
      this.state.redoStack.push(this.dom.ctx.getImageData(0, 0, width, height));
      const prevState = this.state.history.pop();
      if (prevState) {
        this.dom.ctx.putImageData(prevState, 0, 0);
      }
    },

    redo() {
      if (this.state.redoStack.length === 0) return;
      this.saveHistory(false);
      const nextState = this.state.redoStack.pop();
      if (nextState) {
        this.dom.ctx.putImageData(nextState, 0, 0);
      }
    },
  };

  document.addEventListener('DOMContentLoaded', () => app.init());
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <title>Note Link [v5.2]</title>
  <style>
    :root {
      --bg-deep: #2c2c2c; --bg-main: #f0f0f0; --bg-light: #ffffff;
      --ink-main: #1a1a1a; --ink-dim: #5c5c5c;
      --accent-blue: #007aff;
      --border-color: #d1d1d6;
      --topbar-height: 48px; --side-panel-collapsed-w: 52px;
      --side-panel-expanded-w: 280px; --toolbar-height-mobile: 60px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden;
      background-color: var(--bg-deep); color: var(--ink-main);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overscroll-behavior: none;
    }
    .topbar {
      position: fixed; top: 0; left: 0; right: 0; z-index: 100;
      height: var(--topbar-height); display: flex; align-items: center;
      padding: 0 16px; background-color: var(--bg-light); color: var(--ink-main);
      border-bottom: 1px solid var(--border-color);
    }
    .topbar-title { font-weight: 600; font-size: 16px; flex-shrink: 0; }
    .topbar-spacer { flex-grow: 1; min-width: 16px; }
    .topbar-group { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
    .topbar-btn { display: inline-flex; align-items: center; justify-content: center; height: 32px; padding: 0 12px; background-color: #e5e5ea; border: 1px solid var(--border-color); border-radius: 6px; color: var(--ink-main); font-size: 14px; cursor: pointer; white-space: nowrap; }
    .icon-btn { padding: 0; width: 32px; } .icon-btn svg { width: 18px; height: 18px; }

    .main-content { position: fixed; top: var(--topbar-height); right: 0; bottom: 0; left: 0; padding: 20px; display: grid; place-items: center; }
    .canvas-container { width: 100%; height: 100%; box-shadow: 0 4px 16px rgba(0,0,0,0.2); position: relative; }
    .app-canvas { position: absolute; inset: 0; background-color: var(--bg-main); }
    #paint-canvas { touch-action: none; cursor: crosshair; }
    body[data-tool="pan"] #paint-canvas { cursor: grab; }
    
    @media (min-width: 1024px) {
      .main-content { left: var(--side-panel-collapsed-w); }
      .side-panel { position: fixed; top: var(--topbar-height); left: 0; bottom: 0; z-index: 50; width: var(--side-panel-collapsed-w); background-color: var(--bg-light); border-right: 1px solid var(--border-color); display: flex; transition: width 0.3s ease-in-out; }
      body[data-panel-expanded="true"] .side-panel { width: var(--side-panel-expanded-w); }
      .side-panel__tools { width: var(--side-panel-collapsed-w); padding: 8px 0; display: flex; flex-direction: column; align-items: center; gap: 4px; flex-shrink: 0; }
      .tool-btn { width: 40px; height: 40px; display: grid; place-items: center; border: none; background-color: transparent; border-radius: 8px; color: var(--ink-dim); cursor: pointer; }
      .tool-btn[data-active="true"] { background-color: var(--accent-blue); color: white; }
      .tool-btn svg { width: 22px; height: 22px; pointer-events: none; }
      .toolbar-separator { height: 1px; width: 80%; background-color: var(--border-color); margin: 8px 0; }
      .side-panel__settings { width: calc(var(--side-panel-expanded-w) - var(--side-panel-collapsed-w)); padding: 16px; opacity: 0; transition: opacity 0.3s ease-in-out; overflow-y: auto; display: flex; flex-direction: column; gap: 16px; pointer-events: none; }
      body[data-panel-expanded="true"] .side-panel__settings { opacity: 1; pointer-events: auto; }
      .settings-group { display: none; flex-direction: column; gap: 12px; }
      .settings-group[data-visible="true"] { display: flex; }
      .setting-row { display: flex; justify-content: space-between; align-items: center; }
      .setting-row label { font-size: 14px; color: var(--ink-dim); }
      .setting-row input[type="range"] { flex-grow: 1; margin: 0 12px; }
      .value-label { font-size: 14px; min-width: 40px; text-align: right; }
      .mobile-ui { display: none; }
    }
    @media (max-width: 1023px) {
        .main-content { left: 0; padding: 0; }
        .canvas-container { box-shadow: none; }
        .side-panel { display: none; }
        .mobile-ui { position: fixed; bottom: 0; left: 0; right: 0; z-index: 50; background-color: var(--bg-light); border-top: 1px solid var(--border-color); padding-bottom: env(safe-area-inset-bottom); }
        .mobile-toolbar { height: var(--toolbar-height-mobile); display: flex; justify-content: space-around; align-items: center; }
        .mobile-tool-btn { flex: 1; height: 100%; display: grid; place-items: center; background: none; border: none; color: var(--ink-dim); }
        .mobile-tool-btn[data-active="true"] { color: var(--accent-blue); }
        .mobile-tool-btn svg { width: 24px; height: 24px; }
    }
  </style>
</head>
<body data-panel-expanded="true">
  <div class="app-container">
    <header class="topbar"><div class="topbar-title" id="app-title">Note Link</div><span class="topbar-spacer"></span><div class="topbar-group"><button class="topbar-btn" data-action="zoom-out" title="縮小">-</button><button class="topbar-btn" data-action="zoom-reset" title="ズームをリセット">100%</button><button class="topbar-btn" data-action="zoom-in" title="拡大">+</button></div><div class="topbar-group" style="margin-left: 16px;"><button class="topbar-btn icon-btn" data-action="undo" title="元に戻す"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg></button><button class="topbar-btn icon-btn" data-action="redo" title="やり直し"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 0 9 9 9 9 0 0 0 6-2.3L21 13"/></svg></button></div></header>
    <main class="main-content"><div class="canvas-container" id="canvas-container"><canvas id="paint-canvas" class="app-canvas"></canvas></div></main>
    <aside class="side-panel">
      <div class="side-panel__tools">
        <button class="tool-btn" data-action="toggle-panel" title="設定パネルを開閉"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="9" y1="3" x2="9" y2="21"/></svg></button><div class="toolbar-separator"></div>
        <button class="tool-btn" data-tool="pen" title="ペン"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg></button>
        <button class="tool-btn" data-tool="eraser" title="消しゴム"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 12 5 5"/></svg></button>
        <button class="tool-btn" data-tool="pan" title="移動"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 15.5A2.5 2.5 0 0 0 6.5 18H18a2.5 2.5 0 0 0 2.5-2.5V12A2.5 2.5 0 0 0 18 9.5h-3.26a2.5 2.5 0 0 1-2.47-1.8L12 6.5V2.5"/><path d="m18 15-4-4"/><path d="m14 15-4-4"/></svg></button>
      </div>
      <div class="side-panel__settings">
        <div class="settings-group" data-binding="pen eraser">
          <div class="setting-row"><label>サイズ</label><input type="range" min="1" max="100" data-setting="size" title="ブラシサイズ"><span class="value-label" data-value-for="size"></span></div>
        </div>
      </div>
    </aside>
    <div class="mobile-ui">
        <div class="mobile-toolbar">
            <button class="mobile-tool-btn" data-tool="pen" title="ペン"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg></button>
            <button class="mobile-tool-btn" data-tool="eraser" title="消しゴム"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 12 5 5"/></svg></button>
            <button class="mobile-tool-btn" data-tool="pan" title="移動"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 15.5A2.5 2.5 0 0 0 6.5 18H18a2.5 2.5 0 0 0 2.5-2.5V12A2.5 2.5 0 0 0 18 9.5h-3.26a2.5 2.5 0 0 1-2.47-1.8L12 6.5V2.5"/><path d="m18 15-4-4"/><path d="m14 15-4-4"/></svg></button>
        </div>
    </div>
  </div>
<script type="module">
  const app = {
    VERSION: 'v5.2',
    dom: {},
    state: {
      tool: 'pen', dpr: 1, isDrawing: false,
      zoom: 1, pan: { x: 0, y: 0 },
      pointers: [], lastDist: 0, lastPanPoint: null,
      history: [], redoStack: [], currentStroke: null,
      settings: {
        pen: { color: '#1a1a1a', size: 5, lineCap: 'round' },
        eraser: { size: 40, lineCap: 'round'},
      },
      desktopPanelExpanded: true,
    },
    
    init() { this.cacheDom(); this.addEventListeners(); this.setupCanvas(); this.setActiveTool('pen'); this.updateUI(); this.dom.title.textContent = `Note Link ${this.VERSION}`; },
    
    cacheDom() { this.dom = { body: document.body, canvasContainer: document.getElementById('canvas-container'), title: document.getElementById('app-title'), canvas: document.getElementById('paint-canvas'), ctx: document.getElementById('paint-canvas').getContext('2d'), sidePanel: document.querySelector('.side-panel'), zoomResetBtn: document.querySelector('[data-action="zoom-reset"]'), }; },
    
    addEventListeners() {
      window.addEventListener('resize', () => this.setupCanvas());
      const canvas = this.dom.canvas;
      canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));
      canvas.addEventListener('pointermove', this.onPointerMove.bind(this));
      canvas.addEventListener('pointerup', this.onPointerUp.bind(this));
      canvas.addEventListener('pointercancel', this.onPointerUp.bind(this));
      document.body.addEventListener('click', e => {
        const target = e.target.closest('[data-tool], [data-action]'); if (!target) return;
        if (target.dataset.tool) this.setActiveTool(target.dataset.tool);
        if (target.dataset.action) this.handleAction(target.dataset.action);
      });
      this.dom.sidePanel.addEventListener('input', e => this.updateSettingFromElement(e.target.closest('[data-setting]')));
    },
    
    handleAction(action) {
      const center = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      switch (action) {
        case 'toggle-panel': this.state.desktopPanelExpanded = !this.state.desktopPanelExpanded; this.updateUI(); break;
        case 'zoom-in': this.zoomAt(center.x, center.y, 1.25); break;
        case 'zoom-out': this.zoomAt(center.x, center.y, 0.8); break;
        case 'zoom-reset': this.state.zoom = 1; this.state.pan = { x: 0, y: 0 }; this.redrawAll(); break;
        case 'undo': this.undo(); break; case 'redo': this.redo(); break;
      }
    },
    
    setActiveTool(tool) { this.state.tool = tool; this.updateUI(); },

    updateSettingFromElement(element) {
        if (!element) return;
        const key = element.dataset.setting; const value = element.value;
        const toolSettings = this.state.settings[this.state.tool];
        if (toolSettings && key in toolSettings) { toolSettings[key] = value; }
        this.updateUI();
    },
    
    updateUI() {
      this.dom.body.dataset.panelExpanded = this.state.desktopPanelExpanded;
      document.querySelectorAll('[data-tool]').forEach(btn => btn.dataset.active = (btn.dataset.tool === this.state.tool));
      if (this.dom.zoomResetBtn) this.dom.zoomResetBtn.textContent = `${Math.round(this.state.zoom * 100)}%`;
      if (window.innerWidth > 1023) {
        const settings = this.state.settings[this.state.tool];
        if (settings && this.dom.sidePanel) {
          this.dom.sidePanel.querySelectorAll('.settings-group').forEach(group => group.dataset.visible = group.dataset.binding.includes(this.state.tool));
          this.dom.sidePanel.querySelectorAll('[data-setting]').forEach(el => el.value = settings[el.dataset.setting]);
          this.dom.sidePanel.querySelectorAll('.value-label[data-value-for]').forEach(label => label.textContent = settings[label.dataset.valueFor]);
        }
      }
    },
    
    setupCanvas() {
      this.state.dpr = window.devicePixelRatio || 1;
      // Use offsetWidth/Height to get dimensions independent of browser zoom
      const rect = this.dom.canvasContainer;
      const width = rect.offsetWidth;
      const height = rect.offsetHeight;

      this.dom.canvas.width = width * this.state.dpr;
      this.dom.canvas.height = height * this.state.dpr;
      
      this.dom.canvas.style.width = `${width}px`;
      this.dom.canvas.style.height = `${height}px`;

      this.redrawAll();
    },

    getCanvasCoordinates(pointerEvent) {
        const rect = this.dom.canvas.getBoundingClientRect();
        return {
            x: (pointerEvent.clientX - rect.left) / this.state.zoom - this.state.pan.x,
            y: (pointerEvent.clientY - rect.top) / this.state.zoom - this.state.pan.y,
        };
    },

    onPointerDown(e) {
      if (e.pointerType === 'mouse' && e.button !== 0) return;
      e.preventDefault(); this.dom.canvas.setPointerCapture(e.pointerId);
      this.state.pointers.push(e);
      if (this.state.pointers.length > 1) { this.state.isPanning = true; this.state.lastDist = this.getPointerDistance(); return; }
      
      const p = this.getCanvasCoordinates(e);
      if (this.state.tool === 'pan') { this.state.isPanning = true; this.state.lastPanPoint = p; return; }
      
      this.state.isDrawing = true;
      this.state.currentStroke = { ...this.getCurrentSettings(), tool: this.state.tool, points: [p] };
    },

    onPointerMove(e) {
      if (this.state.pointers.length === 0) return;
      const pointerIndex = this.state.pointers.findIndex(p => p.pointerId === e.pointerId);
      if (pointerIndex < 0) return; this.state.pointers[pointerIndex] = e;
      
      if (this.state.pointers.length > 1) { // Zoom
        const dist = this.getPointerDistance();
        if (this.state.lastDist > 0) this.zoomAt(this.getPointerCenter().x, this.getPointerCenter().y, dist / this.state.lastDist);
        this.state.lastDist = dist;
      } else if (this.state.isPanning) { // Pan
        const p = this.getCanvasCoordinates(e);
        this.state.pan.x += p.x - this.state.lastPanPoint.x;
        this.state.pan.y += p.y - this.state.lastPanPoint.y;
        this.redrawAll();
      } else if (this.state.isDrawing) { // Draw
        this.state.currentStroke.points.push(this.getCanvasCoordinates(e));
        this.redrawAll();
      }
    },
    
    onPointerUp(e) {
      this.dom.canvas.releasePointerCapture(e.pointerId);
      this.state.pointers = this.state.pointers.filter(p => p.pointerId !== e.pointerId);
      if (this.state.isDrawing && this.state.currentStroke?.points.length > 0) {
        this.state.history.push(this.state.currentStroke);
        this.state.redoStack = [];
      }
      if (this.state.pointers.length === 0) { this.state.isDrawing = false; this.state.isPanning = false; this.state.currentStroke = null; }
      else if (this.state.pointers.length < 2) { this.state.isPanning = false; this.state.lastDist = 0; }
    },
    
    getPointerDistance() { const [p1, p2] = this.state.pointers; return Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY); },
    getPointerCenter() { const [p1, p2] = this.state.pointers; return { x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 }; },
    
    zoomAt(clientX, clientY, zoomFactor) {
        const rect = this.dom.canvas.getBoundingClientRect();
        const worldX = (clientX - rect.left) / this.state.zoom - this.state.pan.x;
        const worldY = (clientY - rect.top) / this.state.zoom - this.state.pan.y;
        
        const newZoom = Math.max(0.1, Math.min(10, this.state.zoom * zoomFactor));

        this.state.pan.x = (clientX - rect.left) / newZoom - worldX;
        this.state.pan.y = (clientY - rect.top) / newZoom - worldY;
        this.state.zoom = newZoom;
        
        this.redrawAll();
    },
    
    redrawAll() {
      const ctx = this.dom.ctx; const { dpr, zoom, pan } = this.state;
      ctx.save();
      // Use setTransform for a clean slate, applying DPR scaling
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, this.dom.canvas.width, this.dom.canvas.height);
      
      // Apply pan and zoom to the context
      ctx.translate(pan.x, pan.y);
      ctx.scale(zoom, zoom);
      
      for (const stroke of this.state.history) { this.drawStroke(ctx, stroke); }
      if (this.state.isDrawing && this.state.currentStroke) { this.drawStroke(ctx, this.state.currentStroke); }
      
      ctx.restore();
      this.updateUI();
    },
    
    drawStroke(ctx, stroke) {
      if (stroke.points.length < 1) return;
      ctx.beginPath();
      const settings = this.state.settings[stroke.tool] || this.state.settings.pen;
      ctx.strokeStyle = settings.color;
      ctx.lineWidth = settings.size / this.state.zoom; // Keep line width visually consistent
      ctx.lineCap = settings.lineCap;
      ctx.globalCompositeOperation = stroke.tool === 'eraser' ? 'destination-out' : 'source-over';
      
      ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
      for (let i = 1; i < stroke.points.length; i++) { ctx.lineTo(stroke.points[i].x, stroke.points[i].y); }
      ctx.stroke();
    },
    
    getCurrentSettings() { return this.state.settings[this.state.tool] || {}; },
    undo() { if (this.state.history.length === 0) return; this.state.redoStack.push(this.state.history.pop()); this.redrawAll(); },
    redo() { if (this.state.redoStack.length === 0) return; this.state.history.push(this.state.redoStack.pop()); this.redrawAll(); },
  };
  document.addEventListener('DOMContentLoaded', () => app.init());
</script>
</body>
</html>
